iyo's Variant Generator: Technical Specification (v0.7)
1. High-Level Intent

This application is a standalone GUI tool designed to automate the creation of variants for KovaaK's .sce scenario files. Its primary goal is to provide a highly efficient and user-friendly interface for what would otherwise be a tedious, error-prone manual text-editing process.

The application's core design principle is extensibility. The entire system is data-driven, meaning that adding new types of scenario modifiers (like "Gravity" or "Acceleration") can be done by editing a single configuration dictionary at the top of the script, without ever touching the complex core logic.
2. The Domain: Understanding KovaaK's .sce Files

(This section remains accurate and unchanged.)

    Format: A plain text, .ini-style file with key-value pairs (e.g., Timelimit=60.0).

    Structure: Comprises two main parts:

        Global Properties: Settings at the top of the file, before any [...] sections (e.g., the main Name=).

        Sections: Context-specific properties within sections like [Character Profile].

    The "Player vs. Bot" Logic: The application identifies the player's profile via PlayerCharacters= and assumes all other [Character Profile] sections belong to target bots that should be modified.

    Key Challenge - Name Mismatch: The application is explicitly designed to handle cases where a scenario's filename does not match the Name= property inside the file. It treats the user-provided filename as the "source of truth" for creating new variants, while using the internal Name= field as the target for the find-and-replace operation.

3. Core Architecture: A Data-Driven System

The application's architecture is now fully data-driven, orchestrated by a master configuration dictionary.

    The Master Configuration (MODIFIER_CONFIG): This is the "brain" of the entire application. It is a dictionary at the top of the script that defines every available modifier. Each entry contains all the metadata needed for the app to understand it:

        display_name & tag_text: For UI labels and filenames.

        scope: Defines whether the property is Global or found within a Character Profile.

        properties: A list of the actual key names to modify in the .sce file.

        mod_type: Crucially defines the logic to use:

            Multiplier: The standard base_value * percentage.

            Direct: Replaces the value directly (e.g., for Duration).

            Calculated: A special type that uses a different property (calculation_base) for its math (e.g., Regen Rate is based on MaxHealth).

        value_key: Points to the list of values to use from the settings profile (e.g., percentages, hp_percentages).

    The Controller (VariantGeneratorApp): This Tkinter class dynamically builds the UI and orchestrates events based on the MODIFIER_CONFIG.

        Dynamic UI Construction: On startup and on profile load, it reads MODIFIER_CONFIG and the active profile to build the variant columns, their headers, and their values. It no longer contains any hard-coded logic for specific modifiers.

        Scenario Discovery & Auto-Loading: It manages the tk.Listbox for scenarios, provides live filtering via a trace, and uses a "debouncing" mechanism (root.after) to intelligently auto-load scenarios when the user pauses typing a valid filename.

    The Engine (Standalone Functions): These functions are now generalized and data-driven.

        parse_scenario_file: This function reads MODIFIER_CONFIG to learn which properties it needs to look for and extract from the .sce file.

        create_variant_file: This function is the core of the engine. It reads the MODIFIER_CONFIG entry for the requested variant and uses the mod_type and scope to execute the correct modification logic in the correct part of the file. It contains the logic for all modification types (Multiplier, Direct, Calculated).

    The Model (settings.json): This file stores user profiles. Each profile contains the folder path, checkbox states, custom tags, and the specific value lists (percentages, durations, hp_percentages, etc.) that are referenced by the value_key in the MODIFIER_CONFIG.

4. Extensibility Guide: Adding a New Modifier

Adding a new character profile modifier (e.g., "Gravity") is now a simple, three-step process that involves no changes to the core engine logic.

Step 1: Define the Modifier in MODIFIER_CONFIG

Add a new entry to the main dictionary. This is the only mandatory step.
code Python
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

    
# In MODIFIER_CONFIG
"GRAVITY": { 
    "display_name": "Gravity", 
    "tag_text": "Gravity", 
    "mod_type": "Multiplier", 
    "scope": "Character Profile", 
    "properties": ["Gravity"], 
    "condition": None, 
    "suffix": "%", 
    "value_key": "percentages"  # Re-using the standard percentage list
}

  

Step 2: Add Default Values in get_default_profile

If the new modifier needs its own unique list of values, define it here. If it reuses an existing list (like "percentages"), this step can be skipped for that specific value list.
code Python
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

    
# In get_default_profile()
profile = { 
    # ... other lists
    "gravity_percentages": [50, 80, 120, 200], # Add the new list
    # ...
}

# Then, in MODIFIER_CONFIG, you would change "value_key" to "gravity_percentages"

  

Step 3: Add a Display for "Detected Base Stats" (Optional but Recommended)

To show the detected base value in the UI:

    In _create_widgets: Add a new entry to the self.stat_vars dictionary.
    code Python

IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

    
self.stat_vars = { 
    # ... other stats
    "Target Gravity:": tk.StringVar(value="N/A")
}

  

In _on_load: Add a line to populate this new variable.
code Python

    IGNORE_WHEN_COPYING_START
    IGNORE_WHEN_COPYING_END

        
    # In the target_names block
    self.stat_vars["Target Gravity:"].set(first_target_profile.get("Gravity", "N/A"))

      

After these simple changes, the application will automatically handle the rest: creating the new UI column, parsing the new property, saving its settings to profiles, and correctly creating the variant files. The core engine does not need to be touched.
